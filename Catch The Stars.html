<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />

<style id="webmakerstyle">
body {
  margin: 0;
  overflow: hidden;
  text-align: center;
  background: #001f3f;
  color: #fff;
  font-family: Arial, sans-serif;
}

h1 {
  margin: 10px 0;
}

#score {
  font-size: 20px;
  margin: 5px 0;
}

#retryBtn {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 15px 30px;
  font-size: 24px;
  display: none;
  cursor: pointer;
  background: #ffcc00;
  border: 2px solid #000;
  border-radius: 10px;
}

canvas {
  display: block;
  margin: 0 auto;
  background: #001f3f;
}

</style>
</head>
<body>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Catch the Falling Stars</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<h1>Catch the Falling Stars!</h1>
<div id="score">Score: 0</div>
<canvas id="gameCanvas"></canvas>
<button id="retryBtn">Retry</button>
<script src="game.js"></script>
</body>
</html>


<script>const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('score');
const retryBtn = document.getElementById('retryBtn');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let score = 0;
let gameOver = false;
let stars = [];
let bucket = { x: canvas.width/2, y: canvas.height - 60, width: 80, height: 40 };

// Generate random stars
function spawnStar() {
    const star = {
        x: Math.random() * (canvas.width - 30) + 15,
        y: -20,
        size: 20 + Math.random() * 10,
        speed: 2 + Math.random() * 3
    };
    stars.push(star);
}

// Draw 5-pointed star
function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
    let rot = Math.PI / 2 * 3;
    let x = cx;
    let y = cy;
    let step = Math.PI / spikes;

    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius);
    for(let i = 0; i < spikes; i++){
        x = cx + Math.cos(rot) * outerRadius;
        y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;

        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
    }
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fill();
}

// Draw bucket
function drawBucket() {
    const { x, y, width, height } = bucket;
    ctx.fillStyle = 'orange';
    ctx.beginPath();
    ctx.moveTo(x - width/2, y);
    ctx.lineTo(x + width/2, y);
    ctx.lineTo(x + width/3, y + height);
    ctx.lineTo(x - width/3, y + height);
    ctx.closePath();
    ctx.fill();
}

// Update game objects
function update() {
    if(gameOver) return;

    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Draw bucket
    drawBucket();

    // Move and draw stars
    for(let i=stars.length-1; i>=0; i--){
        const s = stars[i];
        s.y += s.speed;

        ctx.fillStyle = 'yellow';
        drawStar(s.x, s.y, 5, s.size/2, s.size/4);

        // Check collision with bucket
        if(s.x + s.size/2 > bucket.x - bucket.width/2 &&
           s.x - s.size/2 < bucket.x + bucket.width/2 &&
           s.y + s.size/2 > bucket.y &&
           s.y - s.size/2 < bucket.y + bucket.height){
            score += 10;
            stars.splice(i,1);
        } else if(s.y - s.size/2 > canvas.height){
            score -= 5;
            stars.splice(i,1);
        }
    }

    scoreDisplay.textContent = 'Score: ' + score;

    requestAnimationFrame(update);
}

// Bucket follows mouse
canvas.addEventListener('mousemove', e => {
    bucket.x = e.clientX;
    bucket.y = e.clientY;
});

// Spawn stars every 0.5 sec
const starInterval = setInterval(() => {
    if(!gameOver) spawnStar();
}, 500);

// End game after 30 sec
setTimeout(() => {
    gameOver = true;
    retryBtn.style.display = 'block';
    alert('Game Over! Final Score: ' + score);
}, 30000);

retryBtn.addEventListener('click', ()=>location.reload());

update();

//# sourceURL=userscript.js
</script>
</body>
</html>